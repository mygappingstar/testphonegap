{:use-macros nil, :excludes #{}, :name rum.derived-atom, :imports nil, :requires nil, :uses nil, :defs {derived-atom {:protocol-inline nil, :meta {:file "/home/thang/.boot/cache/tmp/home/thang/Projects/frontend/mq7/-5h6zy8/app.out/rum/derived_atom.cljc", :line 4, :column 7, :end-line 4, :end-column 19, :arglists (quote ([refs key f] [refs key f opts])), :doc "Use this to create “chains” and acyclic graphs of dependent atoms.\n   `derived-atom` will:\n    - Take N “source” refs\n    - Set up a watch on each of them\n    - Create “sink” atom\n    - When any of source refs changes:\n       - re-run function `f`, passing N dereferenced values of source refs\n       - `reset!` result of `f` to the sink atom\n    - return sink atom\n  \n    (def *a (atom 0))\n    (def *b (atom 1))\n    (def *x (derived-atom [*a *b] ::key\n              (fn [a b]\n                (str a \":\" b))))\n    (type *x) ;; => clojure.lang.Atom\n    \\@*x     ;; => 0:1\n    (swap! *a inc)\n    \\@*x     ;; => 1:1\n    (reset! *b 7)\n    \\@*x     ;; => 1:7\n  \n   Arguments:\n     refs - sequence of source refs\n     key  - unique key to register watcher, see `clojure.core/add-watch`\n     f    - function that must accept N arguments (same as number of source refs)\n            and return a value to be written to the sink ref.\n            Note: `f` will be called with already dereferenced values\n     opts - optional. Map of:\n       :ref           - Use this as sink ref. By default creates new atom\n       :check-equals? - Do an equality check on each update: `(= @sink (f new-vals))`.\n                        If result of `f` is equal to the old one, do not call `reset!`.\n                        Defaults to `true`. Set to false if calling `=` would be expensive", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([refs key f] [refs key f opts]), :arglists ([refs key f] [refs key f opts]), :arglists-meta (nil nil)}}, :name rum.derived-atom/derived-atom, :variadic false, :file "/home/thang/.boot/cache/tmp/home/thang/Projects/frontend/mq7/-5h6zy8/app.out/rum/derived_atom.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([refs key f] [refs key f opts]), :arglists ([refs key f] [refs key f opts]), :arglists-meta (nil nil)}, :method-params ([refs key f] [refs key f opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4, :end-line 4, :max-fixed-arity 4, :fn-var true, :arglists ([refs key f] [refs key f opts]), :doc "Use this to create “chains” and acyclic graphs of dependent atoms.\n   `derived-atom` will:\n    - Take N “source” refs\n    - Set up a watch on each of them\n    - Create “sink” atom\n    - When any of source refs changes:\n       - re-run function `f`, passing N dereferenced values of source refs\n       - `reset!` result of `f` to the sink atom\n    - return sink atom\n  \n    (def *a (atom 0))\n    (def *b (atom 1))\n    (def *x (derived-atom [*a *b] ::key\n              (fn [a b]\n                (str a \":\" b))))\n    (type *x) ;; => clojure.lang.Atom\n    \\@*x     ;; => 0:1\n    (swap! *a inc)\n    \\@*x     ;; => 1:1\n    (reset! *b 7)\n    \\@*x     ;; => 1:7\n  \n   Arguments:\n     refs - sequence of source refs\n     key  - unique key to register watcher, see `clojure.core/add-watch`\n     f    - function that must accept N arguments (same as number of source refs)\n            and return a value to be written to the sink ref.\n            Note: `f` will be called with already dereferenced values\n     opts - optional. Map of:\n       :ref           - Use this as sink ref. By default creates new atom\n       :check-equals? - Do an equality check on each update: `(= @sink (f new-vals))`.\n                        If result of `f` is equal to the old one, do not call `reset!`.\n                        Defaults to `true`. Set to false if calling `=` would be expensive"}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:ref :check-equals?}, :order [:ref :check-equals?]}, :doc nil}